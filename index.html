<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IQUION — Robotics in Progress</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-top: #020817;
      --bg-mid: #020817;
      --bg-bottom: #020817;
      --accent: #38bdf8;
      --accent-soft: rgba(56, 189, 248, 0.18);
      --accent-alt: #a855f7;
      --grid-color: rgba(148, 163, 253, 0.14);
      --border-soft: rgba(148, 163, 253, 0.26);
      --text-main: #e5e7eb;
      --text-soft: #9ca3af;
      --iquion: #f9fafb;
      --danger: #f97316;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background:
        radial-gradient(circle at top, rgba(56,189,248,0.14) 0%, transparent 40%),
        radial-gradient(circle at top right, rgba(168,85,247,0.10) 0%, transparent 40%),
        linear-gradient(to bottom, var(--bg-top), var(--bg-mid), var(--bg-bottom));
      color: var(--text-main);
      min-height: 100vh;
      overflow-x: hidden;
    }

    .page {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 18px;
    }

    /* Background grid */
    .bg-layer {
      position: fixed;
      inset: -60px;
      z-index: -2;
      overflow: hidden;
      pointer-events: none;
    }

    .bg-grid {
      position: absolute;
      inset: -200px;
      background-image:
        linear-gradient(var(--grid-color) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
      background-size: 90px 90px;
      background-position: center;
      opacity: 0.55;
      transition: transform 0.12s ease-out;
      will-change: transform;
    }

    .bg-orbit {
      position: absolute;
      width: 420px;
      height: 420px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 253, 0.16);
      box-shadow: 0 0 40px rgba(56, 189, 248, 0.08);
      top: 16%;
      right: 10%;
      opacity: 0.10;
      pointer-events: none;
    }

    .bg-pulse {
      position: absolute;
      width: 260px;
      height: 260px;
      border-radius: 999px;
      background: radial-gradient(circle, var(--accent-soft) 0%, transparent 70%);
      opacity: 0.22;
      filter: blur(1px);
      transition: transform 0.16s ease-out, opacity 0.2s ease-out;
      will-change: transform, opacity;
      pointer-events: none;
    }

    .bg-pulse:nth-child(2) { top: 10%; left: 10%; }
    .bg-pulse:nth-child(3) { bottom: 12%; right: 14%; }

    /* Hero layout */
    .hero {
      position: relative;
      max-width: 980px;
      width: 100%;
      padding: 26px 26px 22px;
      border-radius: 24px;
      border: 1px solid var(--border-soft);
      background:
        radial-gradient(circle at top left,
          rgba(56, 189, 248, 0.05),
          transparent 65%)
        , rgba(2, 6, 23, 0.95);
      box-shadow:
        0 22px 65px rgba(15, 23, 42, 0.92),
        0 0 36px rgba(79, 70, 229, 0.22);
      backdrop-filter: blur(18px);
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(260px, 1fr);
      gap: 26px;
      align-items: center;
      overflow: hidden;
      transform-style: preserve-3d;
      transition: transform 0.16s ease-out, box-shadow 0.16s ease-out;
    }

    /* Left side text */
    .wip-tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 253, 0.34);
      font-size: 9px;
      color: var(--text-soft);
      margin-bottom: 10px;
      backdrop-filter: blur(12px);
      background: rgba(2, 6, 23, 0.96);
    }

    .wip-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    .logo-text {
      font-size: 32px;
      font-weight: 600;
      letter-spacing: 0.28em;
      text-transform: uppercase;
      color: var(--iquion);
      margin-bottom: 6px;
    }

    .tagline {
      font-size: 13px;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .tagline-en {
      font-size: 11px;
      color: rgba(156, 163, 175, 0.9);
      margin-bottom: 14px;
    }

    .score-wrap {
      display: inline-flex;
      flex-direction: column;
      gap: 2px;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,253,0.26);
      background: rgba(4,7,20,0.98);
      font-size: 8px;
      color: rgba(148,163,253,0.9);
      margin-top: 2px;
    }

    .score-label {
      font-size: 8px;
    }

    .score-value {
      font-size: 9px;
      color: var(--accent);
      font-weight: 500;
    }

    /* Right side: arm + game */
    .arm-wrapper {
      position: relative;
      width: 100%;
      max-width: 320px;
      justify-self: end;
    }

    .arm-label {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 253, 0.26);
      font-size: 8px;
      color: var(--text-soft);
      backdrop-filter: blur(10px);
      background: rgba(2, 6, 23, 0.98);
      display: inline-flex;
      gap: 4px;
      align-items: center;
      z-index: 2;
      cursor: pointer;
      user-select: none;
      transition: border-color 0.16s ease-out, color 0.16s ease-out, background 0.16s ease-out;
    }

    .arm-label-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 1px solid var(--accent);
      box-shadow: 0 0 8px var(--accent);
      transition: border-color 0.16s, box-shadow 0.16s, background-color 0.16s;
      background-color: transparent;
    }

    .arm-label.off {
      border-color: rgba(248, 250, 252, 0.26);
      color: rgba(248, 250, 252, 0.78);
      background: rgba(10, 10, 24, 0.98);
    }

    .arm-label.off .arm-label-icon {
      border-color: var(--danger);
      box-shadow: 0 0 8px var(--danger);
      background-color: rgba(248, 250, 252, 0.08);
    }

    svg#robotArm {
      width: 100%;
      height: auto;
      display: block;
      overflow: visible;
      filter: drop-shadow(0 14px 26px rgba(15,23,42,0.96));
    }

    .arm-base {
      fill: rgba(7, 13, 30, 1);
      stroke: rgba(148, 163, 253, 0.4);
      stroke-width: 1.1;
    }

    .arm-link {
      fill: rgba(10,18,35,1);
      stroke: rgba(129, 140, 248, 0.9);
      stroke-width: 1.2;
    }

    .arm-joint {
      fill: #020817;
      stroke: #38bdf8;
      stroke-width: 1.1;
    }

    .arm-gripper {
      stroke: #38bdf8;
      stroke-width: 1.1;
      stroke-linecap: round;
    }

    .aim-dot {
      fill: rgba(56, 189, 248, 0.38);
    }

    .beam {
      fill: rgba(56, 189, 248, 0.16);
      opacity: 0;
      transition: opacity 0.14s ease-out;
    }

    .beam.active {
      opacity: 1;
    }

    .target-node {
      fill: rgba(168, 85, 247, 0.8);
      stroke: rgba(248, 250, 252, 0.6);
      stroke-width: 0.4;
      transition: transform 0.12s ease-out, fill 0.12s ease-out, stroke 0.12s ease-out;
    }

    .target-node.caught {
      fill: var(--accent);
      stroke: rgba(248, 250, 252, 0.95);
      transform: scale(1.15);
    }

    .hint {
      position: absolute;
      bottom: 6px;
      left: 10px;
      font-size: 7px;
      color: rgba(148, 163, 253, 0.7);
      display: inline-flex;
      gap: 5px;
      align-items: center;
      opacity: 0.9;
      z-index: 2;
      pointer-events: none;
    }

    .hint span {
      font-size: 8px;
      color: var(--accent);
    }

    @media (max-width: 800px) {
      .hero {
        grid-template-columns: 1fr;
        gap: 18px;
      }
      .logo-text {
        font-size: 26px;
        letter-spacing: 0.22em;
      }
      .tagline {
        font-size: 12px;
      }
      .tagline-en {
        font-size: 10px;
      }
      .arm-wrapper {
        max-width: 260px;
        margin: 0 auto 4px;
      }
    }
  </style>
</head>
<body>
  <!-- Background -->
  <div class="bg-layer">
    <div class="bg-grid" id="bgGrid"></div>
    <div class="bg-pulse" id="pulse1"></div>
    <div class="bg-pulse" id="pulse2"></div>
    <div class="bg-orbit"></div>
  </div>

  <main class="page">
    <section class="hero" id="heroCard">
      <!-- Left: minimal teaser -->
      <div>
        <div class="wip-tag">
          <div class="wip-dot"></div>
          IQUION / Work in progress
        </div>
        <div class="logo-text">IQUION</div>
        <div class="tagline">
          Precizna robotika i vid za stvarne sustave. Trenutno u fazi tihog sklapanja.
        </div>
        <div class="tagline-en">
          Precise robotics and vision for real-world systems. Quietly being assembled.
        </div>
        <div class="score-wrap">
          <div class="score-label">Captured nodes</div>
          <div class="score-value" id="scoreValue">0 / 5</div>
        </div>
      </div>

      <!-- Right: robotic arm + mini game -->
      <div class="arm-wrapper">
        <div class="arm-label" id="armToggle">
          <div class="arm-label-icon"></div>
          Mode: Cursor-linked
        </div>
        <svg id="robotArm" viewBox="0 0 240 260" xmlns="http://www.w3.org/2000/svg">
          <!-- Base -->
          <rect x="22" y="210" width="196" height="24" rx="8" class="arm-base" />
          <rect x="52" y="198" width="44" height="6" rx="3" class="arm-base" />
          <circle cx="120" cy="210" r="12" class="arm-joint" />
          <circle cx="120" cy="210" r="4" fill="#38bdf8" />

          <!-- First link -->
          <g id="joint1" transform="translate(120,210)">
            <rect x="0" y="-7" width="78" height="14" rx="6" class="arm-link" />
            <circle cx="0" cy="0" r="5.4" class="arm-joint" />
          </g>

          <!-- Second link + gripper -->
          <g id="joint2" transform="translate(198,210)">
            <rect x="0" y="-5" width="66" height="10" rx="5" class="arm-link" />
            <circle cx="0" cy="0" r="4.6" class="arm-joint" />
            <g id="gripper" transform="translate(66,0)">
              <line x1="0" y1="-4" x2="9" y2="-11" class="arm-gripper" />
              <line x1="0" y1="4" x2="9" y2="11" class="arm-gripper" />
            </g>
          </g>

          <!-- Beam -->
          <polygon id="beam" class="beam" points="0,0 0,0 0,0"></polygon>

          <!-- Aim dot -->
          <circle id="aimDot" cx="180" cy="80" r="3.4" class="aim-dot" />

          <!-- SVG hint -->
          <text x="8" y="248"
            style="fill:rgba(148,163,253,0.7);font-size:7px;font-family:system-ui;">
            Click mode to toggle cursor / auto. Touch nodes to link them.
          </text>
        </svg>
        <div class="hint">
          <span>◆</span> All nodes are reachable. Manual or auto-alignment on click.
        </div>
      </div>
    </section>
  </main>

  <script>
    const grid = document.getElementById("bgGrid");
    const pulse1 = document.getElementById("pulse1");
    const pulse2 = document.getElementById("pulse2");
    const card = document.getElementById("heroCard");
    const svg = document.getElementById("robotArm");
    const j1 = document.getElementById("joint1");
    const j2 = document.getElementById("joint2");
    const aimDot = document.getElementById("aimDot");
    const beam = document.getElementById("beam");
    const scoreValue = document.getElementById("scoreValue");
    const armToggle = document.getElementById("armToggle");

    const L1 = 78;
    const L2 = 66;
    const NUM_TARGETS = 5;

    const state = {
      mouseX: window.innerWidth / 2,
      mouseY: window.innerHeight / 2,
      smoothX: window.innerWidth / 2,
      smoothY: window.innerHeight / 2,
      lastMove: performance.now()
    };

    let followCursor = true;
    let capturedCount = 0;
    let completed = false;
    const targets = [];

    const IDLE_DELAY = 2200;
    const IDLE_RADIUS = 40;

    window.addEventListener("pointermove", (e) => {
      state.mouseX = e.clientX;
      state.mouseY = e.clientY;
      state.lastMove = performance.now();
    });

    if (armToggle) {
      armToggle.addEventListener("click", () => {
        followCursor = !followCursor;
        if (followCursor) {
          armToggle.classList.remove("off");
          armToggle.innerHTML = '<div class="arm-label-icon"></div>Mode: Cursor-linked';
        } else {
          armToggle.classList.add("off");
          armToggle.innerHTML = '<div class="arm-label-icon"></div>Mode: Auto-align';
        }
      });
    }

    function updateBackground(x, y) {
      const nx = x / window.innerWidth - 0.5;
      const ny = y / window.innerHeight - 0.5;

      const tx = nx * -30;
      const ty = ny * -30;
      if (grid) grid.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;

      const p1x = nx * 32;
      const p1y = ny * 18;
      const p2x = nx * -34;
      const p2y = ny * -22;
      if (pulse1) pulse1.style.transform = `translate3d(${p1x}px, ${p1y}px, 0)`;
      if (pulse2) pulse2.style.transform = `translate3d(${p2x}px, ${p2y}px, 0)`;

      const tiltX = ny * 3.5;
      const tiltY = -nx * 3.5;
      if (card) card.style.transform = `rotateX(${tiltX}deg) rotateY(${tiltY}deg)`;
    }

    function updateArm(globalX, globalY, outGripperPos) {
      if (!svg) return;

      const rect = svg.getBoundingClientRect();
      const baseX = 120;
      const baseY = 210;

      let targetX = globalX - rect.left;
      let targetY = globalY - rect.top;

      let dx = targetX - baseX;
      let dy = targetY - baseY;

      let dist = Math.sqrt(dx * dx + dy * dy) || 0.001;
      const minReach = 26;
      const maxReach = L1 + L2 - 4;

      let clamped = dist;
      if (clamped < minReach) clamped = minReach;
      if (clamped > maxReach) clamped = maxReach;

      const scale = clamped / dist;
      dx *= scale;
      dy *= scale;

      const a = L1;
      const b = L2;
      const c = clamped;

      const cosAlpha = (a * a + c * c - b * b) / (2 * a * c);
      const alpha = Math.acos(Math.max(-1, Math.min(1, cosAlpha)));

      const baseAngle = Math.atan2(dy, dx);
      const theta1 = baseAngle - alpha;

      const cosBeta = (a * a + b * b - c * c) / (2 * a * b);
      const beta = Math.acos(Math.max(-1, Math.min(1, cosBeta)));
      const theta2 = Math.PI - beta;

      const deg1 = theta1 * 180 / Math.PI;
      const deg2 = theta2 * 180 / Math.PI;

      j1.setAttribute("transform",
        `translate(${baseX},${baseY}) rotate(${deg1})`
      );

      const joint2X = baseX + Math.cos(theta1) * L1;
      const joint2Y = baseY + Math.sin(theta1) * L1;

      j2.setAttribute("transform",
        `translate(${joint2X},${joint2Y}) rotate(${deg1 + deg2})`
      );

      const gripperX = joint2X + Math.cos(theta1 + theta2) * L2;
      const gripperY = joint2Y + Math.sin(theta1 + theta2) * L2;

      outGripperPos.x = gripperX;
      outGripperPos.y = gripperY;

      const aimX = baseX + dx;
      const aimY = baseY + dy;
      aimDot.setAttribute("cx", aimX);
      aimDot.setAttribute("cy", aimY);

      if (beam) {
        const spread = 5;
        const tipOffset = 10;
        const p1x = gripperX;
        const p1y = gripperY;
        const p2x = aimX - spread;
        const p2y = aimY + tipOffset;
        const p3x = aimX + spread;
        const p3y = aimY + tipOffset;
        beam.setAttribute("points", `${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`);
        beam.classList.add("active");
      }
    }

    function initTargets() {
      if (!svg) return;
      const ns = "http://www.w3.org/2000/svg";

      const baseX = 120;
      const baseY = 210;
      const minR = 40;
      const maxR = L1 + L2 - 12;
      const angleMin = -2.1;
      const angleMax = -0.9;

      for (let i = 0; i < NUM_TARGETS; i++) {
        const c = document.createElementNS(ns, "circle");

        const angle = angleMin + Math.random() * (angleMax - angleMin);
        const r = minR + Math.random() * (maxR - minR);

        let x = baseX + r * Math.cos(angle);
        let y = baseY + r * Math.sin(angle);

        // sigurnosno ograničenje u viewBoxu
        x = Math.max(30, Math.min(210, x));
        y = Math.max(20, Math.min(150, y));

        const radius = 3 + Math.random() * 1.8;

        c.setAttribute("r", radius.toFixed(2));
        c.setAttribute("class", "target-node");
        c.setAttribute("cx", x.toFixed(2));
        c.setAttribute("cy", y.toFixed(2));

        svg.insertBefore(c, beam);

        targets.push({
          elem: c,
          baseX: x,
          baseY: y,
          amp: 4 + Math.random() * 6,
          speed: 0.6 + Math.random() * 0.8,
          phase: Math.random() * Math.PI * 2,
          caught: false,
          x: x,
          y: y
        });
      }
    }

    function updateTargets(now, gripperPos) {
      if (!svg || targets.length === 0) return;

      for (const t of targets) {
        if (!t.caught) {
          const tt = now / 1000 * t.speed + t.phase;
          const x = t.baseX + Math.cos(tt) * t.amp;
          const y = t.baseY + Math.sin(tt * 1.4) * t.amp * 0.7;

          t.x = x;
          t.y = y;
          t.elem.setAttribute("cx", x.toFixed(2));
          t.elem.setAttribute("cy", y.toFixed(2));

          const dx = x - gripperPos.x;
          const dy = y - gripperPos.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 9) {
            t.caught = true;
            t.elem.classList.add("caught");
            capturedCount++;
            updateScore();
          }
        } else {
          t.elem.setAttribute("cx", gripperPos.x.toFixed(2));
          t.elem.setAttribute("cy", gripperPos.y.toFixed(2));
        }
      }

      if (!completed && capturedCount >= NUM_TARGETS) {
        completed = true;
        scoreValue.textContent = `${capturedCount} / ${NUM_TARGETS} · aligned`;
      }
    }

    function updateScore() {
      if (!completed) {
        scoreValue.textContent = `${capturedCount} / ${NUM_TARGETS}`;
      }
    }

    function getAutoTarget() {
      const rect = svg.getBoundingClientRect();
      const uncaught = targets.filter(t => !t.caught);
      if (uncaught.length > 0) {
        const t = uncaught[0];
        return {
          x: rect.left + t.x,
          y: rect.top + t.y
        };
      }
      const cx = rect.left + rect.width / 2;
      const cy = rect.top + rect.height / 2;
      return { x: cx, y: cy };
    }

    function animate(now) {
      let targetX;
      let targetY;

      if (followCursor) {
        const elapsed = now - state.lastMove;
        if (elapsed > IDLE_DELAY) {
          const t = now / 1000;
          targetX = window.innerWidth / 2 + Math.cos(t * 0.6) * IDLE_RADIUS;
          targetY = window.innerHeight / 2 + Math.sin(t * 0.9) * (IDLE_RADIUS * 0.6);
        } else {
          targetX = state.mouseX;
          targetY = state.mouseY;
        }
      } else {
        const auto = getAutoTarget();
        targetX = auto.x;
        targetY = auto.y;
      }

      state.smoothX += (targetX - state.smoothX) * 0.14;
      state.smoothY += (targetY - state.smoothY) * 0.14;

      updateBackground(state.smoothX, state.smoothY);

      const gripperPos = { x: 0, y: 0 };
      updateArm(state.smoothX, state.smoothY, gripperPos);
      updateTargets(now, gripperPos);

      requestAnimationFrame(animate);
    }

    initTargets();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
